# Ticket 29: Единое SSE‑соединение и устойчивый клиент событий

Тип: Architecture / Refactor
Приоритет: Высокий
Оценка: 4–6 часов

---

## Контекст

Сейчас наблюдается множественное создание SSE‑соединений (десятки/тысячи). Это приводит к:
- Лишней нагрузке на бэкенд (каждое соединение — отдельный поток/обработчик).
- Дублированию событий и гонкам при обработке.
- Нестабильности в Dev/StrictMode/HMR (Next.js двойной маунт, горячая перезагрузка).

Причины:
- Использование `useAdminEvents` в нескольких местах (глобальный провайдер и страницы) → каждое место создаёт своё `EventSource`.
- Компоненты могут размонтироваться/смонтироваться повторно при навигации и Dev StrictMode.
- Модульные «шины» событий (`event-bus`) без жёсткого синглтона могут инстанцироваться повторно при HMR/код-сплиттинге.

Цель архитектуры: строго одно SSE‑соединение на вкладку браузера, с распределением событий всем подписчикам.

---

## Решение (архитектура)

Ввести единый устойчивый SSE‑клиент (singleton) + лёгкий подписочный API для компонентов.

### 1) Новый модуль: `web-admin-v2/src/lib/sse-client.ts`

Задачи модуля:
- Хранить единственный `EventSource` (ref) и набор подписчиков (`Set<(evt) => void>`).
- Открывать соединение лениво при первой подписке; закрывать при отсутствии подписчиков (или держать всегда открытым — опционально, см. ниже).
- Нормализовать событие к `{ event, data }` (поддержка бэкенда, публикующего `{ type, ... }`).
- Следить за токеном: при смене токена — «мягкий» реконнект (закрыть старое, открыть новое) с эксп. бэкоффом + джиттер.
- Логировать статусы/ошибки; отдавать статус `connected|connecting|disconnected` подписчикам.
- Быть устойчивым к HMR/StrictMode: хранить инстанс в `globalThis.__zarizSSEClient` и повторно использовать.

Ключевые детали реализации:
- `connect()` проверяет guard: если уже подключено — не создаёт новый `EventSource`.
- `disconnect()` закрывает `EventSource` и очищает таймеры реконнекта.
- `subscribe(handler)` добавляет подписчика и возвращает `unsubscribe()`.
- `authClient.subscribe(...)` вызывает `reconnect()` при смене токена.
- Нормализация событий:
  ```ts
  const raw = JSON.parse(ev.data);
  const normalized = raw && (raw.event || raw.type)
    ? { event: raw.event || raw.type, data: raw.data || raw }
    : { event: 'unknown', data: raw };
  publish(normalized);
  ```
- Backoff с джиттером: до 30с, с обнулением после успешного `onopen`.

Опционально:
- `BroadcastChannel('zariz-sse')` для ретрансляции событий между вкладками (если нужно единое соединение на все вкладки — не обязательно для MVP, по умолчанию допускаем 1 соединение на вкладку).

### 2) Хук подписки: `web-admin-v2/src/hooks/use-sse-events.ts`

- Обёртка над `sseClient.subscribe(handler)` с `useEffect`.
- Возвращает `status` клиента для UI (индикатор соединения).

Пример:
```ts
import { useSSEEvents } from '@/hooks/use-sse-events';

const { status } = useSSEEvents((evt) => {
  if (evt.event === 'order.created') { /* ... */ }
});
```

### 3) Миграция потребителей

- `NotificationProvider`: заменить прямой `useAdminEvents` на `useSSEEvents`. Никаких собственных `EventSource` внутри — только подписка.
- `OrdersPage`: подписываться через `useSSEEvents` (или переиспользовать общий хук типа `useOrderEvents`), без собственного подключения.
- Любые другие места: только подписка на клиент, не создание соединений.

### 4) Депрекация/рефактор старого кода

- Либо удалить `use-admin-events.ts`, либо превратить в тонкую обёртку над `sse-client` (без создания `EventSource`).
- Удалить самодельные «шины» событий, если есть (например, `lib/event-bus.ts`), чтобы исключить расхождение инстансов при HMR.
- Перенести/сконцентрировать всю логику реконнекта, нормализации и логирования в `sse-client.ts`.

### 5) Dev/StrictMode устойчивость

- Глобальный синглтон: `const g = globalThis as any; if (!g.__zarizSSEClient) g.__zarizSSEClient = new SSEClient(); export const sseClient = g.__zarizSSEClient;`
- Guard внутри `connect()` на случай двойного маунта/повторного вызова в Dev.
- Подробные логи: `[SSE] connect/open/message/error/close/reconnect in Xms`.

### 6) Поведение без подписчиков

Вариант A (рекомендуется): держать соединение всегда открытым, пока пользователь на `/dashboard` (NotificationProvider монтируется один раз и подписывается, не создавая при этом второго `EventSource`).

Вариант B: ленивый подход — открывать при первой подписке, закрывать когда подписчиков нет > N секунд. Простое решение: оставить Вариант A для стабильности и простоты.

---

## План работ

1) Добавить `lib/sse-client.ts` с функционалом из п.1.
2) Добавить `hooks/use-sse-events.ts` (п.2).
3) Переписать `NotificationProvider` на `useSSEEvents` (только подписка, без создания соединения).
4) Переписать `OrdersPage` и другие потребители на `useSSEEvents`/`useOrderEvents` (подписка).
5) Удалить/обновить `use-admin-events.ts` (никакого `new EventSource` внутри).
6) Удалить/обновить временный `lib/event-bus.ts` (если создавался), чтобы избежать множественных инстансов при HMR.
7) Прогонка в Dev: убедиться, что в Network → один `EventSource` к `/v1/events/sse` независимо от навигации/модалок.
8) Логи/телеметрия: проверить статусы соединения при офлайн/онлайн/смене токена.

---

## Acceptance Criteria

- В любой момент времени на вкладку браузера — не более одного активного HTTP‑запроса к `/v1/events/sse` (проверка в DevTools → Network).
- Навигация по страницам, открытие/закрытие модалок, Dev StrictMode/HMR не приводит к росту количества соединений.
- События приходят, уведомления и таблица заказов реагируют в реальном времени как раньше.
- При смене токена (рефреш/логаут/логин) — соединение корректно реконнектится без дублирования.
- Логи показывают единый жизненный цикл соединения: `Connecting → Connected → (Errors/Reconnects) → Cleanup`.

---

## Тест‑план

1) Базовый прогон
- Открыть `/dashboard/orders`. В Network должен быть один `EventSource`.
- Создать заказ → тост и строка в таблице появляются без F5.
- Назначить/изменить статус/удалить → таблица обновляется без F5.

2) Навигация
- Переключаться между разделами дашборда 1–2 минуты. Убедиться, что количество SSE‑запросов остаётся 1.

3) Dev StrictMode/HMR
- Внести правку в любой компонент → дождаться Fast Refresh. Проверить, что соединение не множится.

4) Смена токена
- Вручную вызвать `authClient.refresh()` или перелогиниться. Убедиться, что соединение реконнектится и остаётся единичным.

5) Ошибки сети
- Отключить сеть на 10–20 секунд → включить. Убедиться, что идёт эксп. бэкофф, затем восстановление, без множества параллельных подключений.

---

## Риски/ограничения

- Неправильное размещение провайдера/подписчиков может снова породить вторые соединения. Проверить дерево компонентов.
- HMR/код‑сплиттинг может привести к нескольким копиям модуля без глобального синглтона. Обязательно использовать `globalThis`‑гвард.
- При большом числе подписчиков — продумать, чтобы обработка события была быстрой (минимум тяжёлой логики прямо в хендлерах; лучше планировать обновления, троттлить фетчи).

---

## Rollback Plan

- Оставить текущий `useAdminEvents` и отключить миграцию.
- Удалить `sse-client.ts` и `use-sse-events.ts` из импорта.
- Вернуться к одному подключению только в `NotificationProvider` (временно), убедившись, что другие места не создают соединения.

