# Ticket 29 (rev2): Жёстко гарантировать одно SSE‑соединение на вкладку. Диагностика и фиксы

Тип: Architecture / Bugfix / Diagnostics
Приоритет: Высокий
Оценка: 1–2 дня (с диагностикой)

---

## Проблема (факты)

Несмотря на попытку унификации, в DevTools → Network фиксируются тысячи активных запросов к `/v1/events/sse?...` (200 OK). Это означает, что фронтенд продолжает создавать новые `EventSource` без корректного закрытия старых (или открывает их из нескольких путей).

Последствия:
- Перегрузка бэкенда/браузера и дубли событий.
- Рост памяти/дескрипторов, деградация UI.

Дополнительные наблюдения:
- В консоли виден `[SSE] Error` с `readyState: 2 (CLOSED)` у EventSource. Это признак частых разрывов и немедленных реконнектов.
- В Network отображаются множество последовательных 200 OK на `/events/sse` — вероятный признак конкурирующих таймеров реконнекта/мульти‑клиентов.

---

## Гипотезы первопричин

1) Скрытые источники создания `EventSource`:
- Остались вызовы `useAdminEvents` в нескольких местах (помимо глобального провайдера), либо кто‑то напрямую вызывает `new EventSource(...)`.

2) Реактивные перезапуски и Dev StrictMode:
- Эффект с подключением вызывается повторно (StrictMode двойной маунт), нет жёсткой идемпотентности в «connectOnce». 
- Замыкание на `onEvent`/`token` перезапускает эффект без корректного cleanup.

3) Реконнект побочным эффектом:
- `onerror`/timeouterы создают новые подключения, не успевая корректно закрыть старые (гонки `close()`/`connect()`), таймеры не очищаются.

4) Дубли таймеров и отсутствие lock'ов в клиенте:
- В текущей реализации возможна постановка нескольких таймеров реконнекта подряд (каждый `error` планирует новый без отмены предыдущего), что приводит к лавинообразным `connect()`.

5) HMR/Hydration/HMR‑модули:
- Несколько копий модуля (без глобального синглтона) из‑за hot reload → несколько клиентов.

---

## Цель

- Жёстко обеспечить максимум одно активное SSE‑подключение на вкладку.
- Инструментировать код, чтобы легко увидеть причину мультиподключений.

---

## План действий

### Этап 1. Инвентаризация и защита от случайных источников

1) Поиск всех мест создания соединений:
   - `rg -n "new\s+EventSource|EventSource\(|useAdminEvents\(" web-admin-v2/src`
   - Зафиксировать список; любые места кроме одного — кандидаты на удаление/рефактор.

2) Немедленная блокировка многократных подключений в рантайме:
   - В текущем месте создания SSE (временный «центральный» модуль) добавить глобальный замок/счётчик:
     - `globalThis.__zarizSSE = { version, active: boolean, connecting: boolean, refs: number, connects: number }`.
     - При попытке повторного `connect()` если `active || connecting` → строго `return` (лог + stack snapshot в dev).
     - При создании нового — принудительно закрыть предыдущий, если вдруг есть (`try { es.close() } catch {}`), затем создать один.

3) Жёсткий cleanup:
   - На размонтировании единственного владельца (например, в `NotificationProvider`) закрывать соединение и очищать все таймеры.
   - В обработчике `onerror`/реконнекта — всегда отменять предыдущие таймеры перед постановкой нового.

4) StrictMode/HMR‑устойчивость:
   - Модуль с SSE‑клиентом оформляем как синглтон через `globalThis`:
     ```ts
     const g = globalThis as any;
     if (!g.__zarizSSEClient) g.__zarizSSEClient = new SSEClient();
     export const sseClient = g.__zarizSSEClient;
     ```
   - Внутри `connect()` вешаем guard: если уже есть es и `readyState` ≠ `CLOSED` → no‑op.

### Этап 2. Централизация клиента (идемпотентный connect)

1) Добавить `web-admin-v2/src/lib/sse-client.ts` (если ещё нет) с такими гарантиями:
   - Поля: `es: EventSource | null`, `status`, `subscribers: Set<fn>`, `reconnectTimer`, `connecting: boolean`, `connectAttempts: number`.
   - Методы:
     - `connect(force = false)`: если `connecting || es && es.readyState !== EventSource.CLOSED` и `!force` → return.
     - `disconnect()`: закрыть es, очистить таймеры, `status='disconnected'`.
     - `subscribe(fn)`: добавить обработчик, если первый подписчик — `connect()`; возврат `unsubscribe` с удалением.
     - `publish(evt)`: разослать подписчикам.
     - `reconnect(reason)`: `disconnect()` → `connect()` c эксп. бэкоффом + джиттер (макс. 30с), одна активная попытка; перед постановкой нового таймера всегда отменять предыдущий.
   - Нормализация событий: как в предыдущей версии (поддержка `{ type, ... }`).
   - Логи (dev): `[SSE] connect#N`, `[SSE] open`, `[SSE] error`, `[SSE] reconnect in Xms`, `[SSE] disconnect`.

2) Связка с токеном:
   - Подписаться на `authClient.subscribe(...)`; при изменении access_token → `reconnect('token changed')` (без одновременных двойных connect).

3) Отказ от локальных EventSource:
   - Удалить прямое использование `useAdminEvents` (или переписать его как thin‑wrapper над `sseClient.subscribe` без `new EventSource`).
   - Везде использовать хук `use-sse-events.ts` для подписки на `sseClient`.

4) Ликвидация дублирующих импорта типов:
   - Перенести тип `ConnectionStatus` в отдельный модуль `src/types/events.ts` и заменить `import type { ... } from '@/hooks/use-admin-events'` на импорт из `types`, чтобы гарантированно исключить даже теоретическую загрузку устаревшего хука рантаймом.

### Этап 3. Диагностика и контроль

1) Диагностический API в dev:
   - Экспорт `window.__zarizSSEDebug()` → возвращает `{ connects, subscribers, hasES, readyState, timers, lastErrorAt }`.
   - В консоли быстро видно, сколько раз реально пытались подключиться.

2) Детектор дубликатов:
   - В `connect()` сохранять `this.connectMarker = Math.random()`; в логах печатать маркер при каждом событии, чтобы видеть, какое подключение активно.
   - В `onerror` перед постановкой таймера: если `this.reconnectTimeout` уже существует — не ставить второй; логировать "reconnect timer already scheduled".

3) Тест «блокировки»:
   - Намеренно вызвать `sseClient.connect()` несколько раз подряд — должно остаться одно подключение (по дебаг‑логам/Network).

4) Мониторинг в Network:
   - Включить `Preserve log` и отследить, что в любой момент времени «Active» = 1, а не растёт при ошибках/реконнектах.

### Этап 4. Проверка в Dev/HMR/Навигации

1) Включить `Preserve log` в Network и перезагрузить `/dashboard`.
2) Переключаться между страницами 1–2 минуты, проверяя, что активных запросов к `/v1/events/sse` одновременно ровно один.
3) Внести мелкую правку в любой компонент (симулировать HMR) и убедиться, что соединение не множится.
4) Создавать/изменять/удалять заказы и смотреть на стабильность соединения.

---

## Acceptance Criteria

- В любой момент времени на вкладке — ровно 1 активный запрос к `/v1/events/sse`.
- Повторные `connect()` вызовы не создают новые подключения (идемпотентность доказуема логами и `__zarizSSEDebug()`).
- StrictMode/HMR/навигация не увеличивают число подключений.
- События доставляются всем подписчикам (уведомления и таблица обновляются).
- При смене токена/ошибках сети выполняется управляемый реконнект без параллельных подключений.
- При множественных `error` подряд ставится не более одного таймера реконнекта, повторные `error` не создают новые `connect()`.

---

## Риски и снятие

- Наличие забытых вызовов `new EventSource` (глобальным поиском обязателен аудит).
- Некорректный cleanup старых таймеров → гонки реконнекта (строго один таймер, обнуление перед постановкой нового).
- Повторная инициализация клиента из‑за HMR — решается `globalThis`‑синглтоном и guard внутри `connect()`.
- Ошибки сети/прокси (Dev reload, Uvicorn reload) могут провоцировать частые разрывы — должен работать эксп. бэкофф, но без параллельных подключений и без роста числа таймеров.

---

## Rollback Plan

- Вернуться к единственному потребителю SSE в `NotificationProvider` (но убедиться, что он — единственный владелец и подписчики используют только bus без `EventSource`).
- Отключить реконнект и держать соединение открытым, чтобы локализовать проблему (временно, на время диагностики).
